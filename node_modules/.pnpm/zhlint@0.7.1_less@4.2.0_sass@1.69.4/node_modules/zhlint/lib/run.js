"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runWithConfig = exports.run = void 0;
const options_1 = require("./options");
const parser_1 = require("./parser");
const rules_1 = __importDefault(require("./rules"));
const ignore_1 = __importDefault(require("./ignore"));
const join_1 = __importDefault(require("./join"));
const replace_block_1 = __importDefault(require("./replace-block"));
const run = (str, options = {}) => {
    const normalizedOptions = (0, options_1.normalizeOptions)(options);
    return lint(str, normalizedOptions);
};
exports.run = run;
const runWithConfig = (str, config) => {
    const normalizedOptions = (0, options_1.normalizeConfig)(config);
    return lint(str, normalizedOptions);
};
exports.runWithConfig = runWithConfig;
const lint = (str, normalizedOptions) => {
    // return if the file is totally ignored
    const disabledMatcher = /<!--\s*zhlint\s*disabled\s*-->/g;
    if (str.match(disabledMatcher)) {
        return { origin: str, result: str, validations: [], disabled: true };
    }
    const { logger, ignoredCases, rules, hyperParse } = normalizedOptions;
    // init status
    // str -> ignoredByRules, ignoredByParsers
    // blocks -> marks, ignoredMarks
    const status = {
        content: str,
        modifiedContent: str,
        ignoredByRules: ignoredCases,
        ignoredByParsers: [],
        blocks: [
            {
                value: str,
                marks: [],
                start: 0,
                end: str.length - 1
            }
        ]
    };
    const parserErrors = [];
    const ruleErrors = [];
    // Run all the hyper parsers
    const parsedStatus = hyperParse.reduce((current, parse) => parse(current), status);
    // 1. Parse each block without ignoredByParsers
    // 2. Parse all ignoredByRules into marks for each block
    // 3. Run all rule processes for each block
    // 4. Join all tokens with ignoredMarks and all errors for each block
    // 5. Replace each block back to the string
    const ruleHandlers = (0, rules_1.default)(rules);
    const modifiedBlocks = parsedStatus.blocks.map(({ value, marks, start, end }) => {
        let lastValue = value;
        if (globalThis.__DEV__) {
            logger.log('[Original block value]');
            logger.log(lastValue);
        }
        const result = (0, parser_1.toMutableResult)((0, parser_1.parse)(value, marks), rules);
        parserErrors.push(...result.errors);
        const ignoredMarks = (0, ignore_1.default)(value, status.ignoredByRules, logger);
        ruleHandlers.forEach((rule) => {
            (0, parser_1.travel)(result.tokens, rule);
            if (globalThis.__DEV__) {
                const currentValue = (0, join_1.default)(result.tokens, start, ignoredMarks, []);
                if (lastValue !== currentValue) {
                    logger.log(`[After process by ${rule.name}]`);
                    logger.log(currentValue);
                }
                lastValue = currentValue;
            }
        });
        lastValue = (0, join_1.default)(result.tokens, start, ignoredMarks, ruleErrors);
        if (globalThis.__DEV__) {
            logger.log('[Eventual block value]');
            logger.log(lastValue + '\n');
        }
        return {
            start,
            end,
            value: lastValue
        };
    });
    return {
        origin: str,
        result: (0, replace_block_1.default)(str, modifiedBlocks),
        validations: [...parserErrors, ...ruleErrors]
    };
};
exports.default = exports.run;
